# Tech-Interview
## 객체지향이란 무엇인가요 ?
객체지향은 컴퓨터 프로그래밍 패러다임 중 하나로,  
프로그래밍에서 **필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고  
그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍** 방법입니다.

### 캡슐화에 대해 설명해주세요
하나의 객체에 대해 그 **객체가 특정한 목적을 위해 필요한 변수나 메소드를 하나로 묶는 것을 의미**해요.  
캡슐화를 하는 중요한 목적은 **정보의 은닉화** 인데요.  
객체 내에 변수를 private로 선언하여 누군가의 접근에 대비하는 것 뿐만 아니라  
**getter, setter를 이용해서 간접적으로만 접근이 가능하도록 하는게   
캡슐화에 중요한 목적**이에요.

### 추상화에 대해 간략히 설명해주세요
**공통적인 요소나 특징을 추출하는 과정**을 말해요.  
예를 들어보자면 차는 아우디, 벤츠, 벤틀리 등등이 있죠, 이것들을 다 클래스로 만들지 않고  
단지 차 라는 것에 공통적으로 바퀴, 핸들, 문 등 필수적인 부품이 있고 바퀴는 굴러가야하고, 차 문은 열려야하며, 핸들은 좌 우로 돌아가야하죠.    
즉 이 공통적인 행동들을 추출하면 어떤 차든 필수적으로 필요한 메서드가 추출되겠죠 ?  
이렇게 **공통되는 요소, 특징을 줄여가는걸 추상화**라고 해요.

추상화를 하면 얻는 이점은 **코드의 재사용성, 가독성 향상, 생산성 증가, 유지보수 시간 단축 등**이 있어요.

### 다형성에 대해서 설명해주세요
다형성은 **상속을 통해서 기능을 확장하거나 변경하는걸 가능하게 해줘요.**  
이를 통해, 코드의 재사용, 코드의 길이 감소가 되어 **유지보수에 용이**해요.  
쉽게 생각해서 **같은 동작이지만 다른 결과물이 나온다면 이걸 다형성**이라고 볼 수 있어요.  
자바 프로그래밍 객체지향에서 다형성을 녹여내는 방법은 대표적으로 오버라이딩, 오버로딩 이 두가지가 있어요.  
* 오버라이딩(`@Override`) : 부모 즉, **상위 클래스를 상속받아 상위 클래스에서 만들어진 메서드를 자신의 입맛대로 재창조(재정의)**해서 사용하는걸 말해요.
* 오버로딩 : **하나의 클래스 안에서 같은 이름의 메서드를 사용하지만 각 메서드마다 다른 용도로 사용되며, 그 결과물도 다르게 구현할 수 있게 만드는 개념**이에요. 
    > 오버로딩이 가능하려면 메서드끼리 이름은 같지만 매개변수의 갯수나 데이터타입이 다르면 오버로딩이 적용돼요. (매개변수에 따라 호출하는 메서드가 달라져요.)   
    > 메서드 이름이 같아도 문법 에러가 나지않아요.  
    > 메서드 오버로딩을 사용하기 위해선 반환형이 같아야해요.

### 상속, 재사용에 대해서 설명해주세요
상속은 객체지향의 꽃이라고 할 수 있어요.  
상속이란 **기존 상위 클래스에 근거하여 새롭게 클래스와 행위(메서드)를 정의할 수 있게 해주는 개념**이에요.  
기존 클래스에서 기능을 가져와 재사용할 수 있으면서도, 동시에 새롭게 만든 클래스에 새로운 기능을 추가할 수 있게 만들어줘요.  
> 자바에선 단일 상속만 지원되며, C++은 다중 상속이 지원돼요.  
> 이 때문에 원래 자바쪽에서는 다중 상속이 객체 지향적인 관점에서 크게 유효하지 않다고 생각했지만,  
> 다중 상속이 필요할 순 있다고 인정하여 대비책으로 인터페이스를 다중 상속(구현) 할 수 있게해서 임시적인 다중 상속에 대한 길을 뚫어줬어요.  
> 그렇다고 **인터페이스의 존재 이유가 다중 상속을 지원하기 위함이라고 생각하면 안돼요.**

### 인터페이스의 존재이유(사용이유)에 대해서 설명해주세요.
* 개발 시간 단축 : 다른 개발자와 협업을 할 때 다른 개발자가 그 부분을 완성하기 전에 서로 인터페이스로 규약만 정해두어 각자의 부분만 따로 나눠서 작성된 코드를 컴파일 할 수 있어요.
* 클래스간 결합도를 낮출 수 있다 : 코드의 종속성을 줄이고 유지보수성을 높이도록 해줘요.
* 표준화가 가능하다 : 클래스의 기본틀을 제공하여 개발자들에게 정형화된 개발을 강요할 수 있어요.
> 즉 인터페이스는 메서드의 틀을 미리 만들어 개발자간의 의사소통 혼선을 줄여주고 다형성 개발에 유리함을 가져다주는 객체에요.

### 인터페이스와 추상클래스의 차이가 무엇인가요 ?
**추상클래스는 트리형식**으로 상위클래스와 하위클래스로 나뉘어지는 트리구조입니다.  
하위클래스는 상위 클래스에서 추상화시킨 생성자 혹은 메서드를 정의하면서 더 구체화되어갑니다.  
반면에, **인터페이스**는 트리구조와 같은 **수직적 구조가 아닌 수평적 구조를 가지게 됩니다.**  
**추상클래스는 하나의 상위클래스에게만 상속받을 수 있지만, 수평적 구조의 인터페이스는 하나의 클래스가 여러 인터페이스를 가져올 수 있습니다.**

## SOLID 원칙에 대해 설명해주세요
SRP, OCP, LSP, ISP, DIP가 있으며  
시간이 지나도 **유지보수와 확장이 쉬운 시스템을 만들고자 할 때** 이 원칙들을 적용할 수 있습니다.

## 자바 프로그램의 구동원리에 대해 설명해주세요
1. 작성된 소스코드를 컴파일러가 바이트 코드로 변환합니다. (class 파일)
2. JVM이 바이트코드를 해석하여 자바 프로그램이 실행됩니다.
> 바이트코드는 JVM이 이해할 수 있는 언어로 변환된 코드입니다.  
> JVM만 설치되어 있다면 운영체제에 상관없이 자바 프로그램을 실행시킬 수 있습니다.

## LTS란 무엇인가요 ?
LTS란 Long Term Support의 줄임말로  
일반적인 버전보다 장기간에 걸쳐 지원하도록 특별히 고안된 소프트웨어의 버전 또는 에디션입니다.
> Java에서 대표적인 LTS 버전은 Java8, Java11 가장 최근에 나온 Java17이 있어요.

## Java 8 이후로 향상된 기능에는 무엇이 있나요 ?
### Java8 (LTS)
* Lambda 표현식
* Functional 인터페이스
* 인터페이스의 Default method
* Stream
* Optional
* 날짜 관련 클래스 (`java.time`)
* 메서드 레퍼런스

### Java 11 (LTS)
* HTTP/2 지원
* 람다 지역변수 구문 (var)
* 모듈
* 프로파일링 및 진단
* 가비지 수집
* Docker 컨테이너에 대한 향상된 기능
* 성능 향상

### Java 17 (LTS)
* `java.util.Random` 클래스 확장
* 새로운 라이센스 적용

## GC에 대해 설명해주세요
**쓰레기 객체를 청소하는 작업을 GC**라고 합니다.  
**JVM의 Heap 영역**에서 다루며,  
Heap 영역 안에서도 **Young** 영역에서 발생하는 GC는 **마이너 GC**  
**Old** 영역이나 **Perm** 영역에서 발생하는 GC는 **메이저 GC**로 나뉩니다.

## Spring과 Spring Boot의 차이 ?
Spring Boot는 **내부에 Tomcat이 포함되어있어 따로 설치하거나 버전관리를 해주지 않아도 됩니다.**  
또한 **starter를 이용하여 개발 시작단계에 필요한 의존성들을 쉽게 관리**할 수 있습니다. (환경설정을 편하게 해준다.)

## Spring Container가 무엇인가요 ?
자바 객체의 생명주기를 관리하며 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 합니다.  
자바 객체를 스프링에서는 빈(Bean)이라고 부르며,  
스프링 컨네이너는 객체의 인스턴스를 싱글톤으로 관리하므로 싱글톤 컨테이너라고도 불립니다.
> IOC container (DI container)  
> Spring container  
> Singleton container  
> 모두 같은 말이다.

## DI가 무엇인가요 ?
의존성 주입 즉, 객체를 생성하는게 아니라 객체를 외부에서 주입시켜주는 방식입니다.  

DI방식에는 3가지가 있으며 각각의 특징과 차이는 이러합니다.
* 생성자 주입  
**가장 선호하는 방식**이며,  
`final` 키워드 사용으로 **불변성을 통한 오류 방지가 가능**합니다.  
또한 lombok의 어노테이션(`@RequireArgsConstructor`)을 활용하여 간단히 작성할 수 있습니다.  
**순수 자바의 특징을 잘 살리는 방법**입니다.

* 필드 주입  
**코드가 간결하지만 의존관계가 눈에 잘 보이지 않아 추상적이고, 이로 인해 의존성 관계가 과도하게 복잡해질 수 있습니다**.  
그래서 **테스트코드를 제외한 곳에선 잘 사용하지 않습니다.**

* setter 주입  
**선택적으로 의존성을 주입**할 수 있으며  
이에 따라 **의존성이 실수로 변경될 가능성도 존재**합니다.

## IOC가 무엇인가요 ?
제어의 역전이라는 뜻으로,  
**객체에 대한 제어권이 컨테이너로 역전되는 것**을 말합니다.

### IOC가 없다면 어떤상황이 발생하나요 ?
개발자가 직접 객체를 제어해야합니다. (Bean들의 생명주기 관리)  
`new` 연산자를 통해 객체를 생성하고,  
객체의 의존성을 맺어주고, 초기화를 해주는 등..

## PSA(Portable Service Abstraction)가 무엇인가요 ?
호환성있는 서비스 추상화, 즉 잘 만든 인터페이스에요.  
우리가 Low level의 코드를 변경하지 않고 코드 내부 동작 방식을 변경할 수 있어요.  
대표적으로 `build.gradle` 파일에서  
`spring-boot-starter-web` 을 주입하면 **tomcat으로 실행**되고
`spring-boot-starter-webflux` 를 주입하면 **Netty로 실행**돼요.  
이렇듯 우리의 소스코드를 변경하지 않고 내부적으로 동작하는 로직을 변경하여  
관리하는 작업을 Spring에게 맡기고 개발자는 로직에 더 집중할 수 있게 하는게 PSA에요.
> Spring은 특정 기술에 직접적 영향을 받지 않게끔 객체를 POJO 기반으로 한번씩 더 추상화한 Layer를 갖고 있으며,  
> 이를통해 일관성있는 Service Abstraction(서비스 추상화)를 만들어 내요.
> 즉, 사용하는 기술이 바뀌어도 유연하게 대처할 수 있게 해줘요.

## Singleton 패턴은 무엇인가요 ?
**객체의 인스턴스가 오직 1개만 생성되는 패턴**입니다.  
멀티스레드에서 객체를 공유하며 동시성 이슈도 대처할 수 있는 디자인패턴 입니다.  
thread-safe 하게 싱글톤을 구현 하려면  
* `getInstance()`를 통해 단일 인스턴스를 반환하는 방법
* `Synchronized` 키워드를 통해 구현 하는 방법
* `Double Check` 기법
* Java 진영에서 가장 많이 선호하는 `LazyHolder` 방식을 사용하는 방법 등이 있습니다.  

하지만 위의 방법들은 리플렉션으로 조작이 가능합니다.  
**리플렉션으로 조작이 불가능한 싱글톤 패턴을 구현하고 싶다면 Enum class를 활용**해 구현할 수 있습니다. (Enum은 리플렉션이 막혀있다.)
> 싱글톤 패턴의 대표적인 예시로 스프링 컨테이너가 있습니다.  
> 스프링 컨테이너가 관리하는 객체(Bean)는 모두 싱글톤이 보장됩니다. (싱글톤 컨테이너라고도 불림)

## 프레임워크와 라이브러리의 차이가 무엇인가요 ?
먼저 **프레임워크는 정해진 틀에서 프로그래밍을 하는 방식**이며,  
**라이브러리는 먼저 만들어진 코드를 가져다 쓰는 방식**입니다.

## filter와 interceptor의 차이는 무엇인가요 ?
filter는 **dispatcher 서블렛보다 먼저 위치**해있어요.  
또한 servlet 스펙에 포함되어있어요.
그러므로 dispatcher 서블렛에 요청이 전달되기 전에 요청에 대한 부가적인 일을 처리할 수 있어요.  
> (요청에 대한 로깅, 이미지/데이터 압축 및 문자열 인코딩)

interceptor는 spring application(spring context) 내부에 위치해있으며, **dispatcher 서블렛 뒤에 위치**해있어요.
interceptor 또한 Controller로 요청이 전달되기 전에 요청에 대한 부가적인 일을 처리할 수 있어요.   
> (인증/인가 등과 같은 공통 작업, Controller로 넘겨주는 정보의 가공, API 로깅)

## JPA가 무엇인가요 ?
현재 **자바진영의 ORM 기술 표준으로 인터페이스의 모음**입니다.

## JPA의 장점은 무엇인가요 ?
**관계형 데이터베이스와 객체의 패러다임 불일치 문제를 해결할 수 있다는 점과  영속성 컨텍스트 제공이 큰 특징**입니다.

## 영속성 컨텍스트가 무엇인가요 ?
영속성 컨텍스트란 **엔티티를 영구 저장하는 환경이라는 뜻**이며,  
**크게 1차캐시와 쿼리문저장소로 나뉘어집니다.**

### 영속성 컨텍스트의 이점에는 뭐가 있나요 ?
* 1차캐시
* 더티체킹
* 동일성보장
* 쓰기 지연
* 지연로딩

## Hibernate는 무엇인가요 ?
**JPA의 구현체 중에 하나로 JPA의 대부분이 Hibernate로  
구현되었으며 내부적으로 JDBC API를 사용**합니다.

## 즉시로딩과 지연로딩이 무엇인가요 ?
**즉시로딩은 연관된 객체를 한번에 가져오며 쿼리가 날아가는 방식**이고,  
**지연로딩은 연관된 객체를 proxy로 가져와 직접 접근할 때 쿼리가 날아가는 방식**입니다.  

## Querydsl을 사용하시던데 Querydsl의 작성법과 장점을 설명해주세요.
**문자가 아닌 코드로 쿼리를 작성**하고,  
**컴파일 시점에 문법오류를 쉽게 발견할 수 있고 동적인 쿼리 작성이 편리**하다는 장점이 있습니다.  

## 데이터베이스 트랜잭션의 4가지 속성에 대해서 설명해주세요.
**ACID**라고 불리며 순서대로  
* **원자성 (Actomicity)** : 한 트랜잭션 내에서 실행한 적업들은 하나의 단위로 처리한다.  
* **일관성 (Consistency)** : 트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다.  
* **독립성 (격리성, Isolation)** : 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야한다.  
* **지속성 (영속성, Durability)** : 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.

## 스레드가 무엇인가요 ?
**프로세스 내에서 실제로 작업을 수행하는 주체**를 의미합니다.

### 멀티스레드란 무엇인가요 ?
**하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미**합니다.  
이 멀티스레드로 인해 동시성 이슈가 발생합니다.
> `Thread Safe`란, 동시성 문제가 일어나지 않는다는 뜻 입니다.

## 동시성 문제란 무엇인가요 ?
동시성 문제란 **멀티스레드 환경에서 싱글톤이 보장된 하나의 인스턴스의 필드를  
여러 쓰레드가 동시에 접근하여 조회했을 때 조회 결과가 다르게 나오게되는 문제**입니다.  
조회만 할 시에는 발생하지 않으며 **어디선가 값을 변경하기 때문에 발생**하는 문제입니다.

### 동시성 문제를 해결하는 방법은 무엇인가요 ?
* **ThreadLocal**을 사용하여 **쓰레드 단위로 로컬변수를 할당하여 사용**해요.
* **암시적 Lock**, `synchronized` 키워드를 붙여 **한번에 하나의 스레드만 접근할 수 있게**해요.
    * **싱글톤 환경에서 모든 요청에 대해 `synchronized`를 이용하여 처리한다면 성능문제**가 있어요.
* **명시적 Lock**, `ReentrantLock`을 사용하고 **동시에 여러 Lock을 사용하고 싶을 때 사용**해요.
* **스레드에 안전한 객체를 사용**해요
    * `Concurrent` 패키지
        * ex) `ConcurrentHashMap`
* 불변 객체를 만들어요.
    * **객체의 상태를 변화시킬 수 있는 부분을 제거**해요. (`setter`)
    * **객체 내부 상태가 변하지 않도록 변수들을 `final`로 선언**해요 (final 키워드를 사용하면 무조건 초기화를 해야해요.)

## HTTP란 무엇인가요 ?
텍스트 기반의 통신 규약으로 **인터넷에서 데이터를 주고받을 수 있는 프로토콜**입니다.  

## TCP와 UDP의 차이는 무엇인가요 ?
가장 큰 차이는 프로토콜 자체 신뢰성과 비신뢰성, (개발자가 추가로 정의하여 신뢰성을 갖게 할 수 있습니다.)  
TCP는 순서보장 UDP는 순서를 보장하지 않는다 입니다. (UDP가 단순하고 빠름)  
또한 TCP처럼 연결하는데 3번 handshake가 일어나지 않습니다.   
UDP는 개발자가 추가로 정의하여 상황에 맞게 사용해야 합니다.  
> 최근 UDP가 사용되는 대표적인 예시는 HTTP3입니다.

## AWS란 무엇인가요 ?
Amazon Web Service의 줄임말로 클라우드 서비스라고도 해요.
유저가 직접 서버를 구입하고 설치할 필요 없이 AWS상에서 서버를 구축하고 사용할 수 있어요.

## EC2 서버가 한대임에도 불구하고 ELB를 사용한 이유가 무엇인가요 ? (Dotori)
먼저 확장성을 고려했어요.  
그리고 ELB를 거치고 EC2에 접근이 되기 때문에 EC2에 대한 직접접근을 막을 수 있어요.

## Docker란 무엇인가요 ?
컨테이너 기술을 사용하여 애플리케이션에 필요한 환경을 신속하게 구축하고 테스트 및 배포를 할 수 있게 해주는 플랫폼입니다.

## 쿠버네티스란 무엇인가요 ?
쿠버네티스란 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하는 오픈 소스 시스템입니다.

## Stack과 Queue의 차이점은 무엇인가요 ?
Stack은 후입선출(LIFO) 방식으로 쌓아둔 블럭을 위에서부터 제거하는 것 비유를 할 수 있어요.(마지막에 들어온 것이 먼저 나간다.)  
Queue는 선입선출(FIFO) 방식으로 줄서있는 것에 비유할 수 있어요.(먼저 들어온게 먼저 나간다.)