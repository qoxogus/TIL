# 공부하고 강의를 들으며 개인적으로 메모하는 내용을 올리는 공간입니다.

Spring spring-boot

파일구조
Gradle : gradle에 관련
Test : test코드에 관련된 소스 (요즘 개발트렌드에 중요)
Resources : 실제 자바파일을 제외한 XML파일, 설정파일


`./gradlew build`

`./gradlew clean`

`./gradlew clean build`  


컨트롤러가 우선순위  
컨트롤러에 없다면 resources: static을 찾고 있다면 반환


만든 것 : 서비스 리포지토리 멤버객체

구현 : 서비스를 통해서  멤버가입 -> 리포지터리로 저장 -> 리포지토리에서 꺼내올수있고 (테스트코드까지 만들고)

스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술  
3/21 일요일 스프링 빈과 의존관계 시작.

멤버 컨트롤러를 만들어야한다.
멤버 서비스를 통해 회원가입을 하고 멤버서비스를 통해 데이터 조회 (의존관계가 있다)
멤버 컨트롤러가 멤버 서비스를 의존한다 고 표현한다.

멤버 서비스를 가져다 써야한다 new로 생성해서 쓸수도 있겠지만 스프링이 관리를 하게되면 다 스프링컨테이너에 등록을 하고 스프링 컨테이너로부터 받아서 쓰도록 바꿔야함   
(하나 생성후 공용으로 쓰게 만들자)

스프링 빈을 등록하는 2가지 방법
- 컴포넌트 스캔과 자동 의존관계 설정
- 자바코드로 직접 스프링 빈 등록하기
 
——————————————————  
- 컴포넌트 스캔 (@~~ 들 내부를 보면 @Component가 있다 -> 스프링 빈으로 자동등록) 

@Controller -> 스프링 빈으로 자동등록된 이유 : 컴포넌트스캔  
컨테이너가 생기고 컨트롤러 애노테이션이 있다면 MemberController객체를 생성해서 스프링에 넣어둔다 (스프링이 관리함) -> 스프링 관련 콘트롤러 동작하게 되는것!

@Service 
스프링이 서비스로 인식하고 멤버서비스라고 등록해준다

@Repository
리포지토리

스프링이 실행될때 애노테이션(Component) 이 있는것은 다 하나씩 객체를 생성해서 스프링컨테이너에 등록

——————————————————  
그 외 메모

@Autowired (연결한다) (내부에 @Component 없음)  
스프링 컨테이너가 뜰때 멤버콘트롤러가 생성된다  
@Autowired라고 되어있다면 스프링컨테이너에있는 멤버서비스를 가져다가 연결을 해준다  

@Autowired (연결한다)는 밑에처럼 선을 연결해준다.  

스프링컨테이너 (예시 사진)   
helloController -> memberService -> memberRepository  

컨트롤러를 통해서 외부요청을 받고 서비스에서 비즈니스 로직을 만들고 리포지토리에서 데이터 저장을 한다.  

멤버 콘트롤러가 생성이 될때 스프링빈에 등록되어있는 멤버서비스객체를 넣어준다 (DI)의존관계 주입  

멤버서비스는 메모리멤버리포가 필요하다  
@Service인지 -> 컨테이너 등록 -> 생성자 호출 @Autowired가 있으면 -> 멤버리포가 필요하구나하며 스프링컨테이너에 있는 메모리멤버리포를 넣어준다.

스프링 빈 싱글톤 등록?   
(유일하게 하나만 등록해서 공유한다)

———————————————————  
interface는 new가 되지않는다

- 자바코드로 직접 스프링 빈 등록하기
@Configuration -> 스프링이 실행될때 인식한다 그리고 스캔
@Bean -> 멤버서비스 로직을 호출을 해서 빈으로 등록하라는 뜻

멤버 서비스 멤버 리포 둘다 스프링 빈에 등록뒤 스프링빈에 등록되어있는 멤버 리포를 멤버 서비스에 넣어준다

스프링컨테이너 (예시 사진) 
helloController -> memberService -> memberRepository

현재 내 코드
멤버 콘트롤러 -> 멤버서비스 -> 멤버 리포 

콘트롤러는 그대로 두고 콘트롤러 안에 있는 @Autowired는 어쩔수 없다

————————————————————————  
XML방식도 있지만 최근에는 잘 사용하지 않는다

DI에는 필드주입, setter주입, 생성자주입 3가지 방법이 있다. 의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장한다.

필드주입 : 변경방법이 없음;
setter주입 : 중간에 바꾸는 용도지만 public이다.

스프링 실행할때(조립,로딩) 바꾸는거지 도중에 변경되는 경우는 거의 없다.

@Autowired 를 통한 DI는 hello controller, MemberService등과 같이 스프링이 관리하는 객체에서만 동작한다. 스프링빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지않는다
스프링이 관리해야 @Autowired가 적용된다.

변경되야될때는 Config파일을 변경하고 서버를 다시올린다.

실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용한다. 그리고 정형화되지 않거나 상황에 따라 구현 클래스를 변경해야하면 설정을 통해 스프링빈으로 등록한다.

컴포넌츠스캔 -> 무언가를 바꿀때 많은 코드를 수정해야한다
내가 직접 만듦 -> 그 한가지만 바꾸면 된다.   
————————————————————————    
MVC개발   
요청왔을 때 맵핑된게 있다면 스태틱폴더에 인덱스 등은 무시되고 맵핑된게 뜨게된다.

------------------------------------

스프링을 쓰는 이유, 다형성.  
인터페이스를 두고 구현체를 바꿔낄수있음.  

멤버서비스 -> 멤버리포(인터페이스)     

			메모리멤버리포	jdbc멤버리포




멤버서비스는 멤버 리포지포리를 의존하고있다.  
인터페이스 구현체로는 메모리멤버리포와 jdbc멤버리포가 있다.  
서비스에서 메모리멤버리포구현체로 가르키게되어있던것을  jdbc멤버리포구현체로 가르키게 바꿔준다.    

------------------------------------------     
스프링 폴더별 역할
Controller : 클라의 요청을 비즈니스 로직으로 분기 및 수행결과를 응답하는 역할  
————————————————————————  
스프링 데이터 JPA 제공 기능
- 인터페이스를 통한 기본적인 CRUD

- `findByName()`, `findByEmail()`처럼 메서드 이름만으로 조회기능 제공

- 페이징 기능 자동 제공

참고: 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용하면 된다. Querydsl을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다. 이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나, 앞서 학습한 스프링 JdbcTemplate를 사용하면 된다.


순수 JDBC -> 쿼리문이 어마어마함

스프링 JDBCTemplate -> 반복되는 코드양이 줄고 sql직접 작성

JPA -> 기본적인 CRUD를 하는데 쿼리를 작성 할 필요가 없었다 하지만, select 할때는 JPQL이라는걸 직접 짜줬어야했다.

스프링 데이터 JPA -> 아예 구현 클래스를 작성할 필요없이 인터페이스 만으로 개발이 끝남 (제공을 해준다) 

—————————————————————————————  
AOP가 필요한 상황
- 모든 메소드의 호출시간을 축정하고 싶다면?

- 공통관심사항(cross-cutting concern) vs 핵심관심사항(core concern)

- 회원가입시간, 회원조회시간을 측정하고싶다면?


**문제**

- 회원가입, 회원조회에 시간을 측정하는 기능은 핵심 관심 사항이 아니다.

- 시간을 측정하는 로직은 공통 관심 사항이다.

- 시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞여서 유지보수가 어렵다.

- 시간을 측정하는 로직을 별도의 공통 로직으로 만들기 매우 어렵다,

- 시간을 측정하는 로직을 변경할 때 모든 로직을 찾아가면서 변경해야한다.
 
**해결**

- 회원가입, 회원조회등 핵심 관심사항과 시간을 측정하는 공통 관심사항을 분리한다.

- 시간을 측정하는 로직을 별도의 공통 로직으로 만들었다.

- 핵심 관심사항을 깔끔하게 유지할 수 있다.

- 변경이 필요하면 이 로직만 변경하면 된다.

- 원하는 적용 대상을 선택할 수 있다.  


Spring의 동작방식
{스프링 컨테이너}
helloController -> memberService

AOP의 동작방식
{스프링 컨테이너}
helloController -> 프록시memberService 프록시라고 하는 가짜 memberService를 앞에 세워놓음  -> joinPoint.proceed() -> 실제memberService호출

AOP적용후 전체 동작방식
{스프링 컨테이너}
프록시helloController -> helloController   
-> 프록시memberService -> memberService   
-> 프록시memberRepository -> memberRepository  

DI를 해주니까 이런 AOP가 가능한것이다. (프록시방식의 AOP)

